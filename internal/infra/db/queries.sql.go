// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
	"strings"
	"time"
)

const createCarrier = `-- name: CreateCarrier :execresult
INSERT INTO
    carriers (reference, name, registered_number, state_inscription, logo_url, created_at, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?)
`

type CreateCarrierParams struct {
	Reference        int64
	Name             string
	RegisteredNumber string
	StateInscription string
	LogoUrl          string
	CreatedAt        time.Time
	UpdatedAt        time.Time
}

func (q *Queries) CreateCarrier(ctx context.Context, arg CreateCarrierParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createCarrier,
		arg.Reference,
		arg.Name,
		arg.RegisteredNumber,
		arg.StateInscription,
		arg.LogoUrl,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
}

const createDispatcher = `-- name: CreateDispatcher :execresult
INSERT INTO
    dispatchers (id, request_id, registered_number_shipper, registered_number_dispatcher, zipcode_origin, created_at, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?)
`

type CreateDispatcherParams struct {
	ID                         string
	RequestID                  string
	RegisteredNumberShipper    string
	RegisteredNumberDispatcher string
	ZipcodeOrigin              int32
	CreatedAt                  time.Time
	UpdatedAt                  time.Time
}

func (q *Queries) CreateDispatcher(ctx context.Context, arg CreateDispatcherParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createDispatcher,
		arg.ID,
		arg.RequestID,
		arg.RegisteredNumberShipper,
		arg.RegisteredNumberDispatcher,
		arg.ZipcodeOrigin,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
}

const createOffer = `-- name: CreateOffer :execresult
INSERT INTO
    offers (id, dispatcher_id, offer, simulation_type, carrier_id, service, service_code, service_description, delivery_time, original_delivery_time, identifier, delivery_note, home_delivery, carrier_needs_to_return_to_sender, expiration, cost_price, final_price, weights, composition, esg, modal, created_at, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateOfferParams struct {
	ID                           string
	DispatcherID                 string
	Offer                        int32
	SimulationType               int32
	CarrierID                    int64
	Service                      string
	ServiceCode                  sql.NullString
	ServiceDescription           sql.NullString
	DeliveryTime                 json.RawMessage
	OriginalDeliveryTime         json.RawMessage
	Identifier                   sql.NullString
	DeliveryNote                 sql.NullString
	HomeDelivery                 sql.NullBool
	CarrierNeedsToReturnToSender sql.NullBool
	Expiration                   time.Time
	CostPrice                    float64
	FinalPrice                   float64
	Weights                      json.RawMessage
	Composition                  json.RawMessage
	Esg                          json.RawMessage
	Modal                        sql.NullString
	CreatedAt                    time.Time
	UpdatedAt                    time.Time
}

func (q *Queries) CreateOffer(ctx context.Context, arg CreateOfferParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createOffer,
		arg.ID,
		arg.DispatcherID,
		arg.Offer,
		arg.SimulationType,
		arg.CarrierID,
		arg.Service,
		arg.ServiceCode,
		arg.ServiceDescription,
		arg.DeliveryTime,
		arg.OriginalDeliveryTime,
		arg.Identifier,
		arg.DeliveryNote,
		arg.HomeDelivery,
		arg.CarrierNeedsToReturnToSender,
		arg.Expiration,
		arg.CostPrice,
		arg.FinalPrice,
		arg.Weights,
		arg.Composition,
		arg.Esg,
		arg.Modal,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
}

const getCarrierByID = `-- name: GetCarrierByID :one
SELECT
    reference, name, registered_number, state_inscription, logo_url, created_at, updated_at
FROM carriers
WHERE reference = ?
`

func (q *Queries) GetCarrierByID(ctx context.Context, reference int64) (Carrier, error) {
	row := q.db.QueryRowContext(ctx, getCarrierByID, reference)
	var i Carrier
	err := row.Scan(
		&i.Reference,
		&i.Name,
		&i.RegisteredNumber,
		&i.StateInscription,
		&i.LogoUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCarrierMetric = `-- name: GetCarrierMetric :many
SELECT
    carriers.name AS carrier_name,
    COUNT(carrier_id) AS total,
    CAST(SUM(final_price) AS DECIMAL (13,2))  AS final_price_sum,
    CAST(AVG(final_price) AS DECIMAL (13,2)) AS final_price_mean
FROM offers
    JOIN carriers ON offers.carrier_id = carriers.reference
GROUP BY carrier_id ORDER BY carrier_name
`

type GetCarrierMetricRow struct {
	CarrierName    string
	Total          int64
	FinalPriceSum  float64
	FinalPriceMean float64
}

func (q *Queries) GetCarrierMetric(ctx context.Context) ([]GetCarrierMetricRow, error) {
	rows, err := q.db.QueryContext(ctx, getCarrierMetric)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCarrierMetricRow
	for rows.Next() {
		var i GetCarrierMetricRow
		if err := rows.Scan(
			&i.CarrierName,
			&i.Total,
			&i.FinalPriceSum,
			&i.FinalPriceMean,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCarrierMetricsWithLimit = `-- name: GetCarrierMetricsWithLimit :many
SELECT
    r.carrier_name,
    COUNT(r.carrier_id) AS total,
    CAST(SUM(r.final_price) AS DECIMAL (13,2))  AS final_price_sum,
    CAST(AVG(r.final_price) AS DECIMAL (13,2)) AS final_price_mean
FROM (
     SELECT
         offers.carrier_id,
         carriers.name AS carrier_name,
         offers.final_price
     FROM offers
              JOIN carriers ON offers.carrier_id = carriers.reference
     WHERE offers.dispatcher_id IN (/*SLICE:ids*/?)
     ORDER BY offers.created_at
 ) AS r GROUP BY r.carrier_name ORDER BY r.carrier_name
`

type GetCarrierMetricsWithLimitRow struct {
	CarrierName    string
	Total          int64
	FinalPriceSum  float64
	FinalPriceMean float64
}

func (q *Queries) GetCarrierMetricsWithLimit(ctx context.Context, ids []string) ([]GetCarrierMetricsWithLimitRow, error) {
	query := getCarrierMetricsWithLimit
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCarrierMetricsWithLimitRow
	for rows.Next() {
		var i GetCarrierMetricsWithLimitRow
		if err := rows.Scan(
			&i.CarrierName,
			&i.Total,
			&i.FinalPriceSum,
			&i.FinalPriceMean,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDispatcherByID = `-- name: GetDispatcherByID :one
SELECT
    id, request_id, registered_number_shipper, registered_number_dispatcher, zipcode_origin, created_at, updated_at
FROM dispatchers
WHERE id = ?
`

func (q *Queries) GetDispatcherByID(ctx context.Context, id string) (Dispatcher, error) {
	row := q.db.QueryRowContext(ctx, getDispatcherByID, id)
	var i Dispatcher
	err := row.Scan(
		&i.ID,
		&i.RequestID,
		&i.RegisteredNumberShipper,
		&i.RegisteredNumberDispatcher,
		&i.ZipcodeOrigin,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDispatcherIdsWithLimit = `-- name: GetDispatcherIdsWithLimit :many
SELECT
    id
FROM dispatchers
ORDER BY created_at DESC
LIMIT ?
`

func (q *Queries) GetDispatcherIdsWithLimit(ctx context.Context, limit int32) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getDispatcherIdsWithLimit, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOfferByID = `-- name: GetOfferByID :one
SELECT
    id, dispatcher_id, offer, simulation_type, carrier_id, service, service_code, service_description, delivery_time, original_delivery_time, identifier, delivery_note, home_delivery, carrier_needs_to_return_to_sender, expiration, cost_price, final_price, weights, composition, esg, modal, created_at, updated_at
FROM offers
WHERE id = ?
`

func (q *Queries) GetOfferByID(ctx context.Context, id string) (Offer, error) {
	row := q.db.QueryRowContext(ctx, getOfferByID, id)
	var i Offer
	err := row.Scan(
		&i.ID,
		&i.DispatcherID,
		&i.Offer,
		&i.SimulationType,
		&i.CarrierID,
		&i.Service,
		&i.ServiceCode,
		&i.ServiceDescription,
		&i.DeliveryTime,
		&i.OriginalDeliveryTime,
		&i.Identifier,
		&i.DeliveryNote,
		&i.HomeDelivery,
		&i.CarrierNeedsToReturnToSender,
		&i.Expiration,
		&i.CostPrice,
		&i.FinalPrice,
		&i.Weights,
		&i.Composition,
		&i.Esg,
		&i.Modal,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPriceMetric = `-- name: GetPriceMetric :one
SELECT
    CAST(MIN(final_price) AS DECIMAL (13,2)) AS cheaper_shipping,
    CAST(MAX(final_price) AS DECIMAL (13,2)) AS most_expensive_shipping
FROM offers
ORDER BY created_at
`

type GetPriceMetricRow struct {
	CheaperShipping       float64
	MostExpensiveShipping float64
}

func (q *Queries) GetPriceMetric(ctx context.Context) (GetPriceMetricRow, error) {
	row := q.db.QueryRowContext(ctx, getPriceMetric)
	var i GetPriceMetricRow
	err := row.Scan(&i.CheaperShipping, &i.MostExpensiveShipping)
	return i, err
}

const getPriceMetricWithLimit = `-- name: GetPriceMetricWithLimit :one
SELECT
    CAST(MIN(r.final_price) AS DECIMAL (13,2)) AS cheaper_shipping,
    CAST(MAX(r.final_price) AS DECIMAL (13,2)) AS most_expensive_shipping
FROM (
     SELECT
         offers.final_price
     FROM offers
     WHERE offers.dispatcher_id IN (/*SLICE:ids*/?)
     ORDER BY offers.created_at
 ) AS r
`

type GetPriceMetricWithLimitRow struct {
	CheaperShipping       float64
	MostExpensiveShipping float64
}

func (q *Queries) GetPriceMetricWithLimit(ctx context.Context, ids []string) (GetPriceMetricWithLimitRow, error) {
	query := getPriceMetricWithLimit
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	row := q.db.QueryRowContext(ctx, query, queryParams...)
	var i GetPriceMetricWithLimitRow
	err := row.Scan(&i.CheaperShipping, &i.MostExpensiveShipping)
	return i, err
}
